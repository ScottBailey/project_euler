/*

https://projecteuler.net

Triangle, pentagonal, and hexagonal numbers are generated by the following formulae:

Triangle	 	Tn=n(n+1)/2	 	1, 3, 6, 10, 15, ...
Pentagonal	 	Pn=n(3n−1)/2	 	1, 5, 12, 22, 35, ...
Hexagonal	 	Hn=n(2n−1)	 	1, 6, 15, 28, 45, ...

It can be verified that T285 = P165 = H143 = 40755.

Find the next triangle number that is also pentagonal and hexagonal.

NOTES:

*/

fn triangle(n : u64) -> u64 {
    n*(n+1)/2
}

fn pentagonal_to(v : &mut Vec::<u64>, val : u64) {
    while *v.last().unwrap() < val {
        pentagonal_next(v);
    }
}
fn pentagonal_next(v : &mut Vec::<u64>) {
    let n = v.len() as u64 + 1;
    let temp = (3*n-1)*n/2;
    v.push(temp);
}

fn hexagonal_to(v : &mut Vec::<u64>, val : u64) {
    while *v.last().unwrap() < val {
        hexagonal_next(v);
    }
}
fn hexagonal_next(v : &mut Vec::<u64>) {
    let n = v.len() as u64 + 1;
    let temp = (2*n-1)*n;
    v.push(temp);
}


fn solve() -> u64 {

    let mut pent = Vec::<u64>::new(); // storage for pentagonals, prime it as well...
    pentagonal_next(&mut pent);

    let mut hex = Vec::<u64>::new();  // storage for hexagonals
    hexagonal_next(&mut hex);

    let mut n = 285; // set to 284 to test against known input
    loop {
        n += 1;
        let search = triangle(n); // search for this value

        // see if search is pentagonal
        pentagonal_to(&mut pent, search);
        if let Err(_) = pent.binary_search(&search) {
            continue;
        }

        // see if search is hexagonal
        hexagonal_to(&mut hex, search);
        if let Err(_) = hex.binary_search(&search) {
            continue;
        }

        //println!("Found! {} {}", n, search);
        return search;
    }
}


fn main() {
    let start_time = std::time::Instant::now();

    let sol = solve();

    let elapsed = start_time.elapsed().as_micros();
    println!("\nSolution: {}", sol);

    let mut remain = elapsed;
    let mut s = String::new();
    if remain == 0 {
        s.insert(0,'0');
    }
    while remain > 0 {
        let temp = remain%1000;
        remain /= 1000;
        if remain > 0 {
            s = format!(",{:03}",temp) + &s;
        }
        else {
            s = format!("{}",temp) + &s;
        }
    }
    println!("Elasped time: {} us", s);
}
