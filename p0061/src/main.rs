/*

https://projecteuler.net

Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal
numbers are all figurate (polygonal) numbers and are generated by the
following formulae:

  Triangle             P3,n = n(n+1)/2           1, 3, 6, 10, 15, ...
  Square               P4,n = n2                 1, 4, 9, 16, 25, ...
  Pentagonal           P5,n = n(3n−1)/2          1, 5, 12, 22, 35, ...
  Hexagonal            P6,n = n(2n−1)            1, 6, 15, 28, 45, ...
  Heptagonal           P7,n = n(5n−3)/2          1, 7, 18, 34, 55, ...
  Octagonal            P8,n = n(3n−2)            1, 8, 21, 40, 65, ...


The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three
interesting properties.

1. The set is cyclic, in that the last two digits of each number is
   the first two digits of the next number (including the last number
   with the first).

2. Each polygonal type: triangle (P3,127=8128), square (P4,91=8281),
   and pentagonal (P5,44=2882), is represented by a different number
   in the set.

3. This is the only set of 4-digit numbers with this property.

Find the sum of the only ordered set of six cyclic 4-digit numbers for
which each polygonal type: triangle, square, pentagonal, hexagonal,
heptagonal, and octagonal, is represented by a different number in the
set.

*/

use std::collections::HashMap;


struct Container {
    pub four_digit : Vec::<u64>,            // List of all the 4 digit values in the container.
    pub digits : HashMap::<u64,Vec::<u64>>, // Map of first digits to list of last digits for the given first.
}

impl Container {

    pub fn new() -> Self {
        Container { four_digit : Vec::<u64>::new(), digits : HashMap::<u64,Vec::<u64>>::new() }
    }

    pub fn populate_digits(&mut self) {
        for n in &self.four_digit {
            let a = n/100;
            match self.digits.get_mut(&a) {
                Some(v) => v.push(n%100),
                None => {self.digits.insert(a, vec!(n%100));},
            };
        }
    }
}


//fn recurse() -> u64 {





fn solve() -> u64 {

    // Container for Triangle values.
    let mut p3 = Container::new();
    // Populate Triangle values with 4 digit numbers.
    for j in 20.. {
        let temp = p(3,j);
        match temp {
            0..=999 => continue,
            1000..=9999 => p3.four_digit.push(temp),
            _ => break,
        }
    }
    // p3.populate_digits();

    // Vector for values of functions (except Triangle, above): Square, Pentagonal, Hexagonal, Heptagonal, Octagonal.
    let mut v = vec!( Container::new(), Container::new(), Container::new(), Container::new(), Container::new());

    //  Populate vector with 4 digit numbers for all functions.
    for i in 0..=4 {
        for j in 20.. {
            let temp = p(i+4,j);
            match temp {
                0..=999 => continue,
                1000..=9999 => v[i].four_digit.push(temp),
                _ => break,
            }
        }
        v[i].populate_digits();
    }


    //(vindex, subindex)

    for first_full in p3.four_digit {
        let last = first_full/100;
        let next = first_full%100;

        use itertools::Itertools;

        for perm in v.iter().permutations(v.len()) {

            if let Some(list0) = perm[0].digits.get(&next) {
                for next0 in list0 {
                    if let Some(list1) = perm[1].digits.get(&next0) {
                        for next1 in list1 {
                            if let Some(list2) = perm[2].digits.get(&next1) {
                                for next2 in list2 {
                                    if let Some(list3) = perm[3].digits.get(&next2) {
                                        for next3 in list3 {
                                            if let Some(list4) = perm[4].digits.get(&next3) {
                                                for next4 in list4 {

                                                    if *next4 == last {

                                                        let ff0 = next*100+next0;
                                                        let ff1 = next0*100+next1;
                                                        let ff2 = next1*100+next2;
                                                        let ff3 = next2*100+next3;
                                                        let ff4 = next3*100+next4;


                                                        println!("solution! {} {} {} {} {} {}", first_full, ff0, ff1, ff2, ff3, ff4);
                                                        return first_full + ff0 + ff1 + ff2 + ff3 + ff4;

                                                    }

                                                }
                                            }

                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

    }

    panic!("No soution found.");
}


fn p(a : usize, n : u64) -> u64 {
    match a {
        3 => n * (n+1) / 2,
        4 => n * n,
        5 => n * (3*n - 1) / 2,
        6 => n * (2*n - 1),
        7 => n * (5*n - 3) / 2,
        8 => n * (3*n - 2),
        _ => panic!("p(a,n) received out of bounds value for a: {}", a),
    }
}



fn main() {

    let start_time = std::time::Instant::now();

    let sol = solve();

    let elapsed = start_time.elapsed().as_micros();
    println!("\nSolution: {}", sol);

    let mut remain = elapsed;
    let mut s = String::new();
    if remain == 0 {
        s.insert(0,'0');
    }
    while remain > 0 {
        let temp = remain%1000;
        remain /= 1000;
        if remain > 0 {
            s = format!(",{:03}",temp) + &s;
        }
        else {
            s = format!("{}",temp) + &s;
        }
    }
    println!("Elasped time: {} us", s);
}




#[test]
fn test_px() {

    assert!( p(3,1) == 1 );
    assert!( p(3,2) == 3 );
    assert!( p(3,3) == 6 );

    assert!( p(4,1) == 1 );
    assert!( p(4,2) == 4 );
    assert!( p(4,3) == 9 );

    assert!( p(5,1) == 1 );
    assert!( p(5,2) == 5 );
    assert!( p(5,3) == 12 );

    assert!( p(6,1) == 1 );
    assert!( p(6,2) == 6 );
    assert!( p(6,3) == 15 );

    assert!( p(7,1) == 1 );
    assert!( p(7,2) == 7 );
    assert!( p(7,3) == 18 );

    assert!( p(8,1) == 1 );
    assert!( p(8,2) == 8 );
    assert!( p(8,3) == 21 );


}
