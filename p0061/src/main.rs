/*

https://projecteuler.net

Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal
numbers are all figurate (polygonal) numbers and are generated by the
following formulae:

  Triangle             P3,n = n(n+1)/2           1, 3, 6, 10, 15, ...
  Square               P4,n = n2                 1, 4, 9, 16, 25, ...
  Pentagonal           P5,n = n(3n−1)/2          1, 5, 12, 22, 35, ...
  Hexagonal            P6,n = n(2n−1)            1, 6, 15, 28, 45, ...
  Heptagonal           P7,n = n(5n−3)/2          1, 7, 18, 34, 55, ...
  Octagonal            P8,n = n(3n−2)            1, 8, 21, 40, 65, ...


The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three
interesting properties.

1. The set is cyclic, in that the last two digits of each number is
   the first two digits of the next number (including the last number
   with the first).

2. Each polygonal type: triangle (P3,127=8128), square (P4,91=8281),
   and pentagonal (P5,44=2882), is represented by a different number
   in the set.

3. This is the only set of 4-digit numbers with this property.

Find the sum of the only ordered set of six cyclic 4-digit numbers for
which each polygonal type: triangle, square, pentagonal, hexagonal,
heptagonal, and octagonal, is represented by a different number in the
set.

*/

use std::collections::HashMap;

// Figurate function. a is the polynomial (e.g. 3 = Triangle, 4 = Square, etc), n is n. :-)
fn p(a : usize, n : u64) -> u64 {
    match a {
        3 => n * (n+1) / 2,
        4 => n * n,
        5 => n * (3*n - 1) / 2,
        6 => n * (2*n - 1),
        7 => n * (5*n - 3) / 2,
        8 => n * (3*n - 2),
        _ => panic!("p(a,n) received out of bounds value for a: {}", a),
    }
}


// This container will hold all the critical (i.e. 4 digit) figurate
// numbers and then a hash map of the first to digits to a list of the last two digits.q
struct Container {
    pub four_digit : Vec::<u64>,            // List of all the 4 digit values in the container.
    pub digits : HashMap::<u64,Vec::<u64>>, // Map of first digits to list of last digits for the given first.
}

impl Container {

    // Create an initial container of a given polynomial.
    pub fn new(a : usize) -> Self {

        let mut rv = Container { four_digit : Vec::<u64>::new(), digits : HashMap::<u64,Vec::<u64>>::new() };
        // 20 is a rough starting point, values below this are guaranteed to generate a number less than 4 digits.
        for i in 20.. {
            let temp = p(a,i);
            match temp {
                0..=999 => continue,
                1000..=9999 => rv.four_digit.push(temp),
                _ => break,
            }
        }

        for n in &rv.four_digit {
            let b = n/100;
            match rv.digits.get_mut(&b) {
                Some(v) => v.push(n%100),
                None => {rv.digits.insert(b, vec!(n%100));},
            };
        }

        rv
    }
}



fn solve() -> u64 {

    // Container with Triangle values.
    let mut p3 = Container::new(3);
    // Populate Triangle values with 4 digit numbers.
    for j in 20.. {
        let temp = p(3,j);
        match temp {
            0..=999 => continue,
            1000..=9999 => p3.four_digit.push(temp),
            _ => break,
        }
    }
    // Vector for values of functions (except Triangle, above): Square, Pentagonal, Hexagonal, Heptagonal, Octagonal.
    let v = vec!( Container::new(4), Container::new(5), Container::new(6), Container::new(7), Container::new(8));

    // Starting with triangles...
    for first_full in p3.four_digit {
        let last = first_full/100;
        let next = first_full%100;

        // ...iterate over all the premutations of the vector...
        use itertools::Itertools;

        for perm in v.iter().permutations(v.len()) {
            // ...trying to match up the last two digits of the previous number with the first two digits of the next number.
            if let Some(list0) = perm[0].digits.get(&next) {
                for next0 in list0 {
                    if let Some(list1) = perm[1].digits.get(&next0) {
                        for next1 in list1 {
                            if let Some(list2) = perm[2].digits.get(&next1) {
                                for next2 in list2 {
                                    if let Some(list3) = perm[3].digits.get(&next2) {
                                        for next3 in list3 {
                                            if let Some(list4) = perm[4].digits.get(&next3) {
                                                for next4 in list4 {

                                                    // Return when the solution is found.
                                                    if *next4 == last {
                                                        let ff0 = next*100+next0;
                                                        let ff1 = next0*100+next1;
                                                        let ff2 = next1*100+next2;
                                                        let ff3 = next2*100+next3;
                                                        let ff4 = next3*100+next4;
                                                        //println!("solution! {} {} {} {} {} {}", first_full, ff0, ff1, ff2, ff3, ff4);
                                                        return first_full + ff0 + ff1 + ff2 + ff3 + ff4;
                                                    }

                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    panic!("No soution found.");
}





fn main() {

    let start_time = std::time::Instant::now();

    let sol = solve();

    let elapsed = start_time.elapsed().as_micros();
    println!("\nSolution: {}", sol);

    if sol != 28684 {
        panic!("Expected 28684, received {}.", sol);
    }

    let mut remain = elapsed;
    let mut s = String::new();
    if remain == 0 {
        s.insert(0,'0');
    }
    while remain > 0 {
        let temp = remain%1000;
        remain /= 1000;
        if remain > 0 {
            s = format!(",{:03}",temp) + &s;
        }
        else {
            s = format!("{}",temp) + &s;
        }
    }
    println!("Elasped time: {} us", s);
}




#[test]
fn test_px() {

    assert!( p(3,1) == 1 );
    assert!( p(3,2) == 3 );
    assert!( p(3,3) == 6 );

    assert!( p(4,1) == 1 );
    assert!( p(4,2) == 4 );
    assert!( p(4,3) == 9 );

    assert!( p(5,1) == 1 );
    assert!( p(5,2) == 5 );
    assert!( p(5,3) == 12 );

    assert!( p(6,1) == 1 );
    assert!( p(6,2) == 6 );
    assert!( p(6,3) == 15 );

    assert!( p(7,1) == 1 );
    assert!( p(7,2) == 7 );
    assert!( p(7,3) == 18 );

    assert!( p(8,1) == 1 );
    assert!( p(8,2) == 8 );
    assert!( p(8,3) == 21 );


}
